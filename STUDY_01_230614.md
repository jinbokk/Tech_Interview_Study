# STUDY_01_230614

## 브라우저의 동작 방식 ?
브라우저의 동작 방식을 알기 위해 예를 하나 들어보자.

브라우저의 주소창에 www.naver.com 을 입력하고 엔터키를 입력하면 어떻게 될까?

일반적으로는 '네이버 홈페이지로 들어간다' 라고 이야기 하지만, 이 과정을 자세히 들여다보면 DNS를 이용하여 naver.com 라는 도메인 이름을 가진 IP 주소를 찾아가 웹 서버에 있는 자원을 요청하고 받아오는 과정이 있다.

이를 통해 브라우저는 HTML 파일이나 CSS 파일, JS 파일, 이미지 파일 등 다양한 형태의 자료들을 응답받고, 그것들을 분석하고 조합해서 사용자가 보는 화면(View)을 만든다

여기서 ‘코드로 작성된 파일들이 어떻게 눈에 보이는 형태가 되는걸까’ 라는 궁금증이 생기는데, 이는 각 브라우저들이 가지고 있는 ‘렌더링 엔진’ 이 동작하기 때문이다. 

브라우저는 다운로드 한 여러 자료 중, HTML을 먼저 분석하여 구조화하는 파싱작업을 진행한다.
이를 통해 사용자 뷰를 구성할 뼈대를 만드는데, 이것을 DOM Tree라고 한다.

![DOM Tree](https://images.slideplayer.com/35/10310613/slides/slide_10.jpg)   

DOM트리 속의 각 요소는 HTML 파일의 div나 li 태그 등과 같은 요소 노드나, 텍스트 노드, 속성 노드와 같은 노드로 이루어져 있고, Javscript를 이용해 이러한 노드들에 접근하여 페이지를 조작할 수 있는 것이다.

추가적으로, 사용자 View를 스타일링 하기 위해서 CSS 또한 파싱하는 작업을 거쳐 CSSDOM Tree를 만들고, 이것을 DOM Tree와 결합(Attachment)하여 최종적인 Render Tree를 만든다.

이후 렌더링 엔진의 '렌더러' 가 Render Tree를 기반으로 레이아웃과 페인팅 작업을 진행한 뒤 사용자가 보는 화면을 렌더링 하는 것이다.

이렇게 렌더링 된 페이지가 브라우저에 디스플레이 된 후에는, 사용자가 브라우저를 통해 상호작용 하는데 있어서 BOM이 사용된다.
BOM을 사용해서 브라우저상의 클릭 이벤트나, 브라우저 크기를 늘리거나 줄이는 이벤트를 인식하고, 팝업창이나 경고창이 열리게 하는 등의 조작이 가능하다.
 
나름대로 비유를 생각해 보았는데,

- 브라우저는 공장

- HTML, CSS는 공장에 보내는 주문서

- DOM Tree, CSSOM Tree는 공장에서 만든 부품

- Render Tree는 위 2가지를 합쳐 만든 최종 제품.

- 각 공장마다 제품이 다 다르면 사용자에게 혼선을 줄 수 있기 때문에,

  기본적인 기능과 규격을 정해놓는 규격이 W3C 명세

## SSR & CSR
먼저 각 용어에 대해 설명하자면, SSR은 서버-사이드 렌더링, CSR은 클라이언트-사이드 렌더링이다.

말 그대로 서버 단에서 렌더링을 하느냐, 클라이언트 단에서 렌더링을 하느냐의 방식 차이인데,

SSR 방식은, 서버에서 UI가 완전히 구성된 HTML을 클라이언트에 전달하는 방식이다.

![SSR](https://velog.velcdn.com/images%2Fhanei100%2Fpost%2F040f9b95-70a0-49fa-8b73-76272597890c%2Fimage.png)   


완제품을 클라이언트에 전달을 하기 때문에 사용자는 브라우저나 모바일 기기등을 통해 HTML파일을 전달받은 시점에서 바로 페이지를 볼 수 있게 되고, 이후 추가적인 조작을 위한 Javascript 파일이 다운로드 된다.

CSR 방식은, 클라이언트는 먼저 서버로부터 빈 HTML파일을 받게 된다. 

![CSR](https://blog.kakaocdn.net/dn/kFsCv/btrE6zccPL3/3918efAnS6kWmSh6v1sk4K/img.png)   


(여기서 비어있다는 의미는 정말 코드도 없는 빈 파일이라는 뜻이 아니라, root 아이디를 가지는 컨테이너 태그가 있고 그 안에 내용이 없다는 뜻이다.)

그리고 난 뒤에 브라우저가 Javascript를 실행하는데 여기에 React나 Vue와 같은 프레임워크나 라이브러리가 포함되어 있는 것이다.

따라서, 각 프레임워크나 라이브러리의 방식에 따라 Javascript가 실행이 되고, 라우팅 경로에 맞는 파일을 서버에 요청한 뒤, 서버로부터 응답을 받으면 그 데이터를 Javascript가 처리해서 동적으로 UI를 구성하는 방식인 것이다.

(위에서 말한 root Container 태그 안에 각 컴포넌트의 데이터를 렌더링 하는 것)

그래서 페이지별로 HTML파일이 존재하는 것이 아니라, 하나의 root HTML파일이 있고 그 안의 내용만 계속 바꾸는 방식의 SPA (Single Page Application) 가 등장하게 된 것이다.

각각의 방식에는 장단점이 있는데, SSR 방식을 기준으로 설명하자면

- 서버측에서 수행되는 작업이 많기 때문에 서버에 부하가 상대적으로 높다.

- 그러다보니 네트워크의 상태가 서버의 사양이 상대적으로 높아야 한다.

- 매 페이지 로드시마다 서버로부터 새로운 HTML파일을 받아오고 리-렌더링하다보니 페이지 이동간에 다소 느릴수가 있다

- 그렇지만 그 딜레이 이후에 서버에서 브라우저가 곧바로 렌더링 할 수 있는 파일을 전달해주다 보니, 초기 구동 속도가 빠르다.

-  검색엔진이 파일 속 내용을 캐치할 수 있어서 웹페이지가 검색 결과에 잘 노출되어 사용자가 접근하기 쉽다는 장점이 있다. (SEO)


자, 그럼 여기까지 들었을때 약간 혼동이 생길수도 있다.
렌더링은 브라우저단에서 한다고 했던 것 같은데, 또 서버에서도 할 수 있는거고, 클라이언트에서도 할 수 있다는 건가? (본인은 이 부분이 많이 혼란스러웠다)

일단 용어부터 정리하자면, 브라우저는 클라이언트에 속한다.

서버에 정보를 요청하고 응답받는 주체를 클라이언트라고 하는데, 그 수단으로 브라우저가 사용되는 것이다. 스마트폰이 사용될 수도 있는거고.

그리고 서버는 여러 요청에 대한 정보를 가지고 있는 컴퓨터이다. 

DB정보를 가지고 있으면 DB서버, 웹페이지에 대한 정적인 콘텐츠, HTML이나 CSS와 같은 것들을 가지고 있는 컴퓨터면 웹서버 이렇게 부르듯.

자 그럼 다시 돌아와서, 브라우저 렌더링에서의 "렌더" 와, CSR 또는 SSR에서의 "렌더" 는 서로 같은 의미일까?

아니다. 브라우저 렌더링에서의 "렌더"는 DOM Tree와 CSSOM Tree를 조합하여 Render Tree를 만들어서 렌더러로 렌더하고, 사용자에게 보여질 뷰를 만드는 "전체 과정"을 뜻한다고 한다면,

CSR과 SSR에서의 "렌더"는 HTML을 생성하고 화면에 표시하는 과정을 의미한다.
즉, 브라우저에서 렌더링을 하기 위해 HTML이 필요한데, 그것이 서버에서 처리된 채로 받아오는 방식이 SSR,
미완성인채로 클라이언트가 받아서 비동기적으로 처리하는 방식이 CSR 인 것이다. 서로 렌더링을 하는 위치와 방식에 차이가 있는 것이다.

---
### 질문

1. 브라우저의 동작 방식에 대해 이해한 대로 설명 해 본다면?

2. 브라우저에서 DOM 이 무엇인지?

3. 브라우저에서 DOM 이 왜 필요한지?

4. 브라우저에서 각각의 렌더링 엔진으로 DOM Tree를 작성하는데, 

    Naver 웹사이트를 크롬에서 보나 엣지에서 보나 똑같은 이유는?

5. SSR과 CSR이 무엇인지 이해한 대로 설명 해 본다면?

6. SSR과 CSR이 어떠한 차이를 가지고 있는지?

7. SSR과 CSR의 장단점은 무엇일까?
---


## 운영체제
- 하드웨어 (CPU,GPU,RAM 등) 와 소프트웨어 (응용 프로그램) 사이의 인터페이스.
- 컴퓨터의 자원을 관리하며, 이때 자원이란 CPU-프로세스, 메모리, 저장장치, 네트워크 등을 뜻한다.
- 또한, 시스템을 구성하는 여러 하드웨어를 운영체제가 인식하고 관리할 수 있도록 하기 위해서 ‘드라이버 (Driver)’ 를 이용한다.
