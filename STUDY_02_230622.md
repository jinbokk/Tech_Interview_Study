# STUDY_02_230622

# 이진복

## ❓쿠키 / 세션

### 쿠키란?

- 쿠키는 웹 서버가 클라이언트(웹 브라우저 등)에 저장하는 작은 데이터 조각이다.

- 쿠키는 사용자의 컴퓨터에 저장되며, 웹 브라우저가 서버로 요청을 보낼 때마다 해당 요청과 함께 서버에 전송된다.

- 주로 사용자 인증, 세션 유지, 개인화된 경험 제공 등에 사용된다.

- 쿠키는 이름-값 쌍으로 이루어져 있으며, 만료 날짜와 경로 등의 속성을 가질 수 있다.

- 클라이언트에서 생성, 관리, 삭제되기 때문에 보안상 주의가 필요하다. (악의적인 사용자가 쿠키를 변경하거나 조작할 수 있으므로 중요한 데이터를 저장하거나 보안에 민감한 정보를 쿠키에 저장해서는 안된다)
---

### 세션이란?

- 세션은 서버 측에서 사용자의 상태를 유지하기 위한 메커니즘이다.

- 세션은 서버에서 생성되고, 클라이언트와 서버 간의 고유한 식별자인 세션 ID를 클라이언트에게 제공한다.

- 서버는 세션 ID를 사용하여 클라이언트의 세션 정보를 식별하고, 필요한 데이터를 서버 측에 저장한다.

- 세션은 일반적으로 보안상 안전하며, 서버 측에서 관리되기 때문에 클라이언트에서 데이터를 조작하기 어렵다.
  
  하지만 서버 측에 상태 정보를 유지하기 위해 자원을 사용하므로 확장성에 주의해야 한다.


---

| | Cookie | Session |
| --- | --- | --- |
| 저장 위치 | 클라이언트 | 서버 |
| 저장 형식| 텍스트 (키-값 페어) | 객체 (일반적으로 해시 테이블 또는 배열 형태) |
| 만료 시점 | 쿠키 저장시 설정 <br/> (부가 설정이 없다면 브라우저 종료시) | 정확한 시점 없음  <br/>(세션 만료시) |
| 리소스  | 클라이언트 리소스 | 서버의 리소스 |
| 용량 제한 | 한 도메인 당 20개, 한 쿠키당 4KB | 제한 없음|

---
## 쿠키와 세션은 왜 사용하는 것일까?

### 1. 상태 유지

널리 쓰이는 HTTP 프로토콜은 기본적으로 상태를 유지하지 않는다.
즉, 클라이언트가 서버에 요청을 보낼 때 마다 이전의 요청에 대한 정보는 사라진다.
따라서 유저의 로그인 정보나, 유저가 설정한 개인 설정들이 사라지게 되는데, 이러한 한계를 극복하기 위해
쿠키와 세션이 등장하고 사용되었다.

* HTTP (Hypertext Transfer Protocol) ?

![HTTP/HTTPS](https://www.hostinger.com/tutorials/wp-content/uploads/sites/2/2021/10/what-are-the-differences-between-http-and-https-2.webp)   

인터넷에서 데이터를 주고받기 위해 사용되는 프로토콜이다. 클라이언트와 서버 간의 통신 규격을 정의하여 웹 브라우저와 웹 서버가 정보를 주고받을 수 있도록 한다. 이때 요청과 응답이 모두 헤더(header)와 본문(body)가 포함된 텍스트 메시지로 이루어 지고, 따로 암호화 되어있지 않아 보안에 취약하다는 문제점이 발생하여, 현재는 HTTP와 SSL을 결합한 보안 버전인 HTTPS이 사용되고 있다.

* SSL (Secure Sockets Layer) ?

![SSL](https://i.imgur.com/NWmUEzb.png)   

![계층구조](https://images.velog.io/images/leeinae/post/a0fd2526-03ba-4d71-ae2b-fce058edf362/TCP%20%EA%B3%84%EC%B8%B5.png)   


평문으로 데이터를 주고받는 HTTP 방식에 보안을 더하는 레이어이다.

기본적인 과정은 아래와 같다.

1. 클라이언트측과 서버측이 모두 Key Pair를 생성한다
> - 클라이언트 : Public Key(C) + Private Key(C)
> - 서버 : Public Key(S) + Private Key(S)

2. 클라이언트와 서버가 서로 각자의 Public Key를 서로 교환한다. (IKE. Internet Key Exchange)
> - 클라이언트 : Public Key(C) + Private Key(C) **<u>+ Public Key(S)</u>**
> - 서버 : Public Key(S) + Private Key(S) **<u>+ Public Key(C)</u>**

3. Public Key는 말그대로 Public이기 때문에 보안에 취약하다. 따라서 Public Key는 각자의 정보를 전송할 때 '암호화'를 하는데만 사용을 한다. 

4. 클라이언트가 서버측에 요청을 보낼 때를 예를 들면, 3번의 과정처럼
클라이언트는 서버에 보내고자 하는 데이터를 **Public Key(S) 로 암호화** 한다.

5. 서버는 클라이언트가 보내준 암호화 된 데이터를 자신의 **Private Key(S) 로 복호화** 한다.

이러한 방식이 **비대칭키 방식**이다.

## !! 그러나, 실제로는 이렇게 사용하지 않는다.

비대칭키 방식처럼 클라이언트와 서버가 모두 Key Pair를 생성하는 과정이 비용(연산)이 많이 드는 과정이기 때문이다. 
또한, 비용을 소모해서 만든 Key Pair는 어느정도 시간이 지난 후에 폐기가 되기 마련이다.

따라서, 매번 요청마다 Key Pair를 만드는 것이 아니라, 서버가 미리 Key Pair를 만들어 두고 저장장치에 저장해 둔 뒤에
매 요청마다 필요시에 사용하는 방식으로 '효율적으로' 변화하게 되었는데, 이 과정중에 등장한 것이 바로 '대칭키 + 비대칭키' 방식이다.

다시 위처럼 클라이언트가 서버측에 요청을 보낼 때를 예를 들면,

1. 서버는 통신 전에 미리 Public Key(S) + Private Key(S) 를 만들어 둔다.

2. 클라이언트와 서버가 통신을 시작하면, 클라이언트는 이전처럼 Key Pair를 만드는 것이 아닌, **'대칭키 (Symmetric Key)' **를 생성한다. 이 대칭키는 평문을 암호화 하거나, 암호문을 복호화 할때 모두 사용이 된다.
> - 클라이언트 : Symmetric Key(C)
> - 서버 : Public Key(S) + Private Key(S)

3. 클라이언트와 서버간 키를 교환한다.

이때, 클라이언트는 서버의 Public Key(S)를 전달 받고
클라이언트는 서버로부터 받은 Public Key(S)를 이용하여 본인의 Symmetric Key(C)를 암호화 하여 서버로 보낸다.
서버는 이것을 다시 본인의 Private Key(S)로 복호화하고, 이때 암호화 되었던 클라이언트의 Symmetric Key(C)를
복호화 하여 평문으로 가지고 있게 된다.

> - 클라이언트 : Symmetric Key(C) **<u>+ Public Key(S)</u>**
> - 서버 : Public Key(S) + Private Key(S) **<u>+ Symmetric Key(C)</u>**

즉, 대칭키 방식에서 키 교환 과정중 보안에 취약하다는 문제점을 비대칭키 방식을 함께 사용하여 해결하면서,
동시에 비대칭키 방식에서 높은 비용 소모의 문제를 대칭키 방식으로 효율적으로 전환할 수 있게 되는 것이다. 

이렇게 클라이언트-서버의 통신을 하나의 세션이라고 보았을 때, 대칭키를 '세션키' 라고 부르기도 한다.


자 그럼 지금까지 HTTP와 HTTPS를 공부하면서 그 배경지식이 되는 인증 방식에 대해 잠시 알아보았다.

다시 돌아와서, SSL은 이 과정중에 어디에서 어떻게 사용이 되는 것일까?

클라이언트-서버간 Key를 교환하는 IKE 과정을 다시 보자. 

클라이언트 측에서 예를 들면, 클라이언트는 서버로부터 받은 Public Key(S)를 이용하여 암호화를 한다.

이때 Public Key(S)가 안전한지, 누군가로부터 위변조는 되지 않았는지 신뢰할 수 없다면 이를 이용한 암호화는
안전하다고 할 수 없다. (MITM 공격 노출 위험 등) 그렇기 때문에, 바로 이 과정에 SSL이 사용되는 것이다.

클라이언트가 서버로부터 받은 Public Key(S)를 어떠한 인증기관을 통해 검증한다.
(이때 인증기관은 클라이언트와 서버측 모두가 신뢰한다는 사실을 기반으로 한다.)

인증기관은 크게 2가지가 있다. CA (Certification Authority) / RA (Registration Authority).
CA-RA는 서로 파트너 관계라고 생각하면 된다.
> - CA - ( DataBase ) - RA
> - ( CA-RA간 공유하는 DataBase가 있고, 인증서 목록을 공유한다 )

클라이언트-서버의 통신 과정중 서버가 Key Pair를 만들고자 할 때, RA에게 요청을 하고, RA가 Key Pair를 생성하고 서버에게 전달해주며 동시에 RA의 HDD에 저장한다.
 
> **RA (Registration Authority)**
>- ( Public Key (RA) + **<u>Hash / Signature ( CA의 "Private Key로" 암호화 되어있음. 기존 방식과 반대임 )</u>**+ Public Date + Expire Date +  ...etc ) = **Certification(RA)**
>- Private Key (RA)

> **서버**
> - RA로부터 받은 Certification(RA)
> - Private Key(S)

CA는 자신의 Public Key(CA)로 RA로부터 생성된 Certification(RA)을 검증한다.
이때 Certification 안에는 RA의 Public Key(RA) 를 포함한 여러 정보들과 **암호화된 Hash**가 포함 되어있는데,
이를 복호화 하기 위해 CA의 Public Key(CA) 이용한다.

> **CA (Certification Authority)**
>- Public Key (CA)
>- Private Key (CA)

다시 돌아와서, 클라이언트는 서버로부터 받은 Certification(RA)을 검증해야 하는데, 클라이언트는 이를 어떻게 처리하는 것일까? CA가 가지고 있는 Public Key(CA)와 Private Key(CA)가 필요한데 클라이언트는 이를 어떻게 가지고 있는 것일까?

예를 들어, 클라이언트가 Microsoft사의 Window OS를 사용한다고 가정했을 때, Microsoft사는 VeriSign CA사와 제휴가 되어있다. PC의 보안 업데이트 등이 이루어질 때, 보안 제휴가 되어있는 VeriSign CA사의 여러 인증서들을 설치하는데,
이때 설치된 인증서들 속에 Public Key (CA)가 있는 것이고, 이것이 바로 서버로부터 받은 Certification(RA)를 검증하는데 사용되는 것이다.

(cmd로 certmgr.msc를 실행하면 그 내역을 확인할 수 있다)

여기까지가 기존 HTTP에 위 처럼 SSL(보안층)을 새로 더한 과정이고, 이를 HTTPS 라고 한다.

---

### 2. 사용자 식별 및 인증

- 쿠키와 세션을 사용하여 사용자를 식별하고 인증할 수 있다. 로그인한 사용자에게 고유한 세션 ID를 제공하고, 해당 세션 ID를 쿠키에 저장하여 사용자를 식별하는 방식이 그 예인데, 이를 통해 사용자의 로그인 상태를 유지하고, 사용자가 인증된 요청을 보낼 때마다 해당 세션에 대한 인증을 수행할 수 있다. (EESO CAKE PROJECT에서도 이와 같이 사용)
---
### 3. 개인화된 경험 제공

- 쿠키와 세션을 사용하여 사용자의 선호도나 이전 활동 내역을 기반으로 개인화된 경험을 제공할 수 있다. 예를 들어, 사용자의 언어 설정, 테마 선호도, 최근 본 상품 등을 쿠키나 세션에 저장하여 해당 정보를 활용해 사용자에게 맞춤화된 콘텐츠를 제공할 수 있다.
---
### 4. 추적과 분석

- 쿠키를 사용하여 웹 분석 도구와(구글 애널리틱스 등) 같은 서비스를 통해 사용자의 웹 사용 패턴을 추적하고 분석할 수 있습니다. 이를 통해 웹 사이트의 성능 향상과 사용자 경험 개선에 도움이 된다. 예를 들어, 방문자 수, 방문한 페이지, 장바구니 담기 횟수 등을 쿠키를 통해 추적하여 분석할 수 있다.
---

## 쿠키가 로컬스토리지와 같은건가요?

쿠키와 로컬 스토리지는 데이터를 클라이언트 측에 저장하는 데 사용된다는 공통점이 있어서 헷갈릴 수 있지만, 서로 다른 메커니즘이다. 

쿠키는 브라우저 세션 동안에만 유효하거나, 만료 날짜를 설정하여 지속적으로 사용될 수 있다. 반면에 로컬 스토리지는 데이터가 브라우저를 종료하더라도 직접 삭제하지 않는 이상 영구적으로 유지되는 특징이 있다.

(EESO CAKE PROJECT에서도 자동 로그인 기능을 구현하며 고민했던 부분이다. 쿠키에 민감한 정보가 포함되어 있다면 클라이언트-서버의 통신 과정중에 노출이 될 수 있을 것이라고 생각하여, 클라이언트 측에서만 접근이 가능한 로컬스토리지에 영구적으로 보관하는 방식을 선택했다) 

---

## ❓ Rest API ?

### API가 뭔가요?

어떠한 프로그램을 사용하기 위한 인터페이스라고 생각하면 된다.
리모콘을 예로 들자면, 채널 변경 버튼을 누르면 사용자는 TV 내부의 동작 과정은 몰라도 채널이 변경된다.
핸드폰 또한 볼륨을 높이는 버튼을 누르면, 그 과정을 몰라도 볼륨이 높아진다.

즉, API는 어플리케이션 간에 지정된 형식으로 요청과 응답을 할 수 있도록 연결하는 인터페이스 인 것이다.

### REST는요?

웹에서 주로 사용되는 REST API는 URI와 HTTP를 기반으로 하고, 브라우저간 호환성이 좋은 JSON 형식을 주로 사용한다. REST 형식은 과거의 복잡한 SOAP 형식을 대체하며 오늘날 널리 사용되고 있다.

아래는 javascript와 axios 라이브러리를 사용한 각각의 요청 예시이다

### SOAP

```javascript
const axios = require('axios');
const xml2js = require('xml2js');

const soapRequest = `<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:exam="http://example.com/">
    <soapenv:Header/>
    <soapenv:Body>
        <exam:GetProduct>
            <exam:id>123</exam:id>
        </exam:GetProduct>
    </soapenv:Body>
</soapenv:Envelope>`;

axios.post('http://example.com/soap-endpoint', soapRequest, {
  headers: {
    'Content-Type': 'text/xml',
  },
})
  .then(response => {
    const xmlResponse = response.data;
    xml2js.parseString(xmlResponse, (error, result) => {
      if (error) {
        console.error(error);
      } else {
        const product = result['soapenv:Envelope']['soapenv:Body'][0]['exam:GetProductResponse'][0]['exam:Product'][0];
        console.log(product);
      }
    });
  })
  .catch(error => {
    console.error(error);
  });
```

### REST

```javascript
const axios = require('axios');

axios.get('http://example.com/api/products/123')
  .then(response => {
    const product = response.data;
    console.log(product);
  })
  .catch(error => {
    console.error(error);
  });
```

---

### REST의 특징은?

1. 리소스 중심 (Resource-Centric)

    REST(ful) API는 데이터를 리소스로 생각한다. 각 리소스는 고유한 주소(URI)를 가지며, 이를 통해 클라이언트가 해당 리소스를 식별하고 요청할 수 있다. 예를 들어, 사용자 정보를 나타내는 리소스는 "/users"로 표현된다.

2. HTTP 메서드 활용

    리소스 중심이라는 특징과 함께, HTTP 메서드를 사용하여 각 리소스에 대한 작업을 표현한다. "/users" 에 보내는 요청을 예로 들면, GET은 유저를 가져오기 위해 사용되고, POST는 새로운 유저를 생성하기 위해 사용된다. PUT은 유저 정보를 전체적으로 수정하고, DELETE는 유저 정보를 삭제한다. 이러한 메서드를 사용하여 API의 의도를 명확하게 전달할 수 있다.

3. 무상태성 (Statelessness)

     REST(ful) API는 클라이언트의 상태를 관리하지 않는다. 즉, 클라이언트의 세션 정보나, 인증상태 등을 관리하지 않는다는 것이다. 예를 들어, RESTful API가 아닌 로그인 기능을 가진 웹 어플리케이션이 있다고 가정했을 때, 사용자가 아이디와 비밀번호로 로그인하면 서버는 해당 사용자의 세션을 생성하고 유지하며, 클라이언트의 각 요청마다 서버는 세션을 확인하여 사용자의 인증 상태를 알 수 있게 된다.

    하지만 RESTful API에서는 서버가 클라이언트의 상태를 유지하지 않는다. 예를 들어, 사용자가 로그인을 하여 인증 토큰을 발급 받으면 클라이언트는 이 토큰을 요청의 Authorization 헤더에 포함시켜 API에 요청을 보내고, 서버는 각 요청마다 해당 토큰을 확인하여 인증 상태를 판단하고 요청을 처리하면 되는 것이다.

    즉, RESTful API는 클라이언트의 각 요청에 인증 정보를 포함시킴으로써 서버가 세션을 유지하고 확인하는 번거로움을 없애는 방식인 것이다.

4. 캐시 가능성 (Cacheability)

    REST(ful) API는 캐싱을 지원하여 응답을 클라이언트나 중간 계층에서 저장할 수 있다. 이는 동일한 요청에 대한 처리를 효율적으로 수행하고, 네트워크 부하를 줄여준다.

5. 자체 표현성 (Self-descriptiveness)

    REST(ful) API는 요청과 응답의 메시지 자체가 리소스를 식별하고 표현할 수 있어야 한다. URI를 통해 리소스에 접근하고, HTTP 헤더와 메서드를 사용하여 요청의 의도를 명시한다. 응답은 리소스의 상태와 관련된 정보를 제공하여 자체적으로 설명이 가능하다.

---

### RESTful API가 뭔가요 ?

간단히 말해서, REST API는 REST의 일부 원칙을 따를 수도 있지만, RESTful API는 REST의 모든 원칙을 엄격하게 따르는 API라고 할 수 있다.

먼저, 개발이라는 것이 혼자서 이뤄지는 것이 아닌 협업을 통해 이뤄진다는 것을 염두에 두어야 한다.
혼자 하는 개발이라면 REST API 방식을 이용하여 어떠한 요청을 보내고, 그것에 대한 응답을 받는데 있어서, 결과만 좋으면 상관이 없다.

`(GET) https://www.jbschool.com/1 = 학원 학생 리스트 요청`

`(GET) https://www.jbschool.com/hello = 학원 수업 리스트 요청`

`(GET) https://www.jbschool.com/nice = 학원 수업 리스트 변경 요청`

😒 **"URI는 제각각이지만, 응답도 잘 받아오고 혼자 개발하니까 괜찮아"**

그러나, 오늘날 많은 개발자가 함께 협업을 하고 있고, 적절히 통일되어 있는 요청 방식을 사용하지 않으면 이를 해석하기 위해 많은 비용이 낭비될 수 있다.

따라서 REST API에서 더 나아가, REST의 모든 원칙을 엄격히 따르는 RESTful API가 등장하게 된 것이다. RESTful 형식은 각 요청이 어떤 정보나 동작을 위한 것인지 명시적으로 표현되어 있어 그 자체만으로 추론이 가능하다.

`(GET) https://www.jbschool.com/student = 학원 학생 리스트 요청`

`(POST (with body)) https://www.jbschool.com/class = 학원 수업 리스트 추가 요청`

`(GET) https://www.jbschool.com/class?grade=A = 학원 수업 리스트 중 A 등급의 수업 리스트 요청 `

🤓 **"URI만 보고도 어느정도 유추할 수 있네!"**

---

### CRUD가 뭔가요?

HTTP로 요청을 보낼 때 사용할 수 있는 다양한 메서드들이 있다.
(GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH)

REST API에서는 이 중 4~5가지를 사용한다 (GET,POST,PUT,DELETE,(PATCH))
>POST,PUT,PATCH 메서드의 경우 'body' 라는 데이터를 담을 수 있는 공간이 있어서
GET이나 DELETE보다 더 많은 정보를 안전하게 요청에 담을 수 있다. 

이러한 메서드들을 이용하여 데이터를 CREATE, READ, UPDATE, DELETE 하는 동작을 수행하는 것을 앞글자만 따서 CRUD 라고 한다.

---

- 쿠키와 세션은 무엇이며 어떤 차이가 있나요?

- 쿠키와 세션은 왜 사용하나요?

- 쿠키와 로컬스토리지의 차이점은 무엇인가요?

- REST API가 뭔가요?

- REST API와 RESTful API의 차이점이 뭔가요?

- POST 메서드도 CRUD가 모두 가능하지만 왜 CREATE에만 사용할까요? RESTful API와 관련지어 설명한다면?

<details><summary>
답변
</summary>
- POST나 PUT, GET 등의 메서드를 사용해서 CRUD가 가능하다. 하지만, 만약 POST 메서드만으로 CRUD를 하고 그것을 REST API로 표현하고, 개발자간에 소통을 원활히 하기 위해서는 아래와 같이 URI에 명시적으로 표시가 되어야 한다. 

`(POST) https://www.jbschool.com/class/create = 학원 수업 리스트 추가 요청`

`(POST) https://www.jbschool.com/class/read = 학원 수업 리스트 요청`

`(POST) https://www.jbschool.com/class/update = 학원 수업 리스트 업데이트 요청`

이는 REST 방식에서 지양하는 부분이며 이와 관련해서, RESTful 방식에서는 URI에 동사를 사용하면 안된다는 엄격한 규칙이 있다.
</details>

- RESTful API의 특징이 무엇인가요? 가장 주요한 특징은 무엇인가요?

---

# 지준혁

# 2. 프로세스와 스레드

### [개념]

- 프로세스 : `실행 중인 프로그램`을 의미한다.
- 프로세스는 운영체제로부터 독립된 주소 공간을 할당받는다.
- 독립된 주소공간은 다음의 영역으로 나뉜다.
    - Code 영역: 코드 자체를 구성하는 메모리 영역
    - Data 영역: 전역변수, 정적변수
    - Heap 영역: 동적할당 시 사용되는 영역
    - Stack 영역: 지역변수, 매개변수, 리턴 값
- 스레드: 프로세스 내에서 `실행되는 흐름의 단위`를 말한다.
- 특징
    - 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 각 스레드는 동시에 실행될 수 있다.
    - 스레드는 `각각 별도의 스택(Stack)메모리 영역`을 가지지만,  코드, 데이터, 힙 영역 은 프로세스 내 모든 스레드가 공유한다.

### [상태]

- 프로세스는 크게 3가지 상태가 있다.
1. `실행(Running)`: 프로세스는 프로세서에서 실행중이다. 명령어를 실행하고 있다.
2. `준비(Ready)`: 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다.
3. `대기(Blocked)`: 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산이다. ex) 입출력 요청 시 입출력이 완료될 때까지 대기(blocked)상태가 된다.

### [자료구조]

- 운영체제는 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보(`Process Control Block, PCB`)를 둔다.
- 이는 OS 메모리 영역 중 Data부분에 저장된다.
- PCB가 관리하는 정보
    1. OS가 관리상 사용하는 정보
        - Process state(프로세스 상태), Process ID(프로세스 이름), scheduling information(스케줄링 정보)
    2. CPU 수행 관련 하드웨어 값
        - Program counter(현재 실행 중인 명령어의 주소를 가리키는 레지스터)
        - registers(CPU 내부에 위치한 작은 메모리 공간)
    3. 메모리 관련
        - code, data, stack의 위치 정보(stack pointer - 스택 최상단 가리키는 포인터)
    4. 파일 관련
        - open filde descriptors…

# 3. CPU 스케줄링

### [스케줄링 평가 항목(scheduling metric)]

- `반환 시간(turnaround time)`
- `공정성(fairness)`
- `응답시간(response time)`

1. **선입선출 (First In First Out, FIFO)**

- 먼저 들어온 것을 먼저 처리한다.
- 단순하고 구현하기 쉽지만, convoy effect가 발생할 수 있다.
    - convoy effect: 짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상을 말한다.

2. **최단 작업 우선(Shortest Job First, SJF)**

- 가장 짧은 실행 시간을 작업을 먼저 실행시킨다.
- 모든 작업이 동시에 도착한다면 SJF가 `최적(optimal)`을 보장한다.
- 오래 걸리는 작업이 큐에 먼저 도착한 경우 이전의 convoy effect가 다시 발생한다.

3. **최소 잔여시간 우선(Shortest Time-to-Completion Fisrt, STCF)**

- 언제든 새로운 작업이 시스템에 들어오면, 스케줄러는 남아 있는 작업과 새로운 작업의 잔여 실행 시간을 계산하고 그 중 가장 적은 잔여 실행 시간을 가진 작업을 스케줄한다.

4. **라운드 로빈(Round-Robin, RR)**

- 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.
- 시분할 컴퓨터의 등장으로 상호작용을 원할하기 위한 성능을 요구하게 되고, 응답 시간(response time)이라는 새로운 평가기준이 필요하게 되었다.
- 작업이 실행되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling quantum)이라 부른다.
- 타임 슬라이스가 짧을수록, 응답 시간 기준으로 RR의 성능은 더 좋아진다. 하지만 너무 짧게 하면, 문맥 전환 비용이 전체 성능에 큰 영향을 미치게 된다.

### [**스케줄링의 두가지 접근법]**

1. 남아 있는 작업 중 실행 시간이 제일 짧은 시간을 수행하고, 반환시간을 최소화한다. (CPU-집중-작업들에 유리)
2. 모든 작업을 번갈아 실행시키고 응답 시간을 최소화한다. (대화형-작업들에 유리)

### [멀티 레벨 피드백 큐(MLFQ, Multi Level Feedback Queue)의 기본 작동방식]

- Priority(A) > priority(B)이면 A가 실행된다.
- Priority(A) = priority(B)이면 RR방식으로 실행된다.
- 작업이 시스템에 들어가면 최상위 큐에 배치된다.
- 작업이 지정된 단계에서 배정받은 시간을 소진하면 작업의 우선순위는 감소한다.
- 일정 주기 S가 지난 후, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

### [멀티프로세서에서 CPU스케줄링]

- 캐시에 관해 먼저 살펴보자
    - CPU에는 하드웨어 캐시 계층이 존재한다. 자주 접근되는 데이터를 캐시에 임시로 가져다 둠으로써 크고 느린 메모리를 빠른 메모리처럼 보이게 한다.
    - 캐시는 지역성에 기반한다
        - 시간 지역성: 데이터가 한 번 접근되면 가까운 미래에 다시 접근되기 쉽다는 것이다.
        - 공간 지역성: 프로그램이 주소 x의 데이터에 접근하면 x 주변의 데이터가 접근되기 쉽다는 것이다

****1. `캐시 일관성 문제(cache coherence)`**

- 멀티 프로세서 시스템에서 CPU마다 캐시를 가지고 있다면 CPU1 캐시에 존재하는 데이터가 CPU2 캐시에는 존재하지 않아서 데이터 불일치 문제가 생길 수 있다.
- 해결책
    
    → 여러 개의 프로세스들이 하나의 메모리에 갱신할 때에는 공유되도록 한다. 버스 기반 시스템에서는 이를 버스 스누핑(bus snooping)이라고 한다.
    
    → 캐시 데이터에 대한 변경이 발생하면, 자신의 복사본을 무효시키거나(자신의 캐시에서 삭제), 갱신(새로운 값을 캐시에 기록)한다.
    
1. **`동기화 문제`**
    - 캐시에 일관성이 보장된다고 하더라도, 프로그램 또는 운영체제는 공유데이터에 접근할 때 동기화 기법을 사용해야 한다.
    - 해결책
        
        → 상호배제를 보장하는 기법인 락-프리(lock free)데이터 구조를 이용한다.
        
2. **`캐시 친화성(cache affinity)`**
    - 캐시 친화성이란 데이터 접근 패턴을 최적화하여 캐시 메모리를 효율적으로 활용하는 것이다. 프로세스가 실행될 때 해당 CPU 캐시와 TLB에 상당한 정보를 올려놓기 때문이다. 매번 다른 CPU에서 실행한다면 필요한 정보를 다시 탑재해야 하는 오버헤드가 발생한다.

# 4. 메모리 가상화

- 왜 메모리 가상화가 필요할까? 가상 메모리란 무엇이고. 어떤 이점을 제공하는가?
    
    프로그램 입장에서 어떤 명령어를 실행하기 전에 매번 자신의 메모리가 충분하게 있는지 살펴보는 건 비효율적이다. 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상을 만들어줘야 한다. 
    
    즉, 가상 메모리란 메모리 관리 기법 중 하나로 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 작업을 말한다. 상대적으로 큰 저장공간인 스왑 영역을 활용하여 프로세스마다 가상의 주소 공간을 확보하고, 필요한 페이지만 물리 메모리에 올려 사용함으로써 더 효과적으로 메모리를 사용하는 기법이다.
    
    1. 사용자 프로그램이 물리 메모리의 제약에서 벗어난다.
        - 사용자 프로그램이 물리 메모리보다 커져도 된다. 프로그래머는 물리메모리 크기를 신경쓸 필요 없다.
    2. 각 프로그램이 더 적은 메모리를 차지하기 때문에 더 많은 프로그램을 동시수행 할 수 있다.
        - 프로세스 당 메모리 사용량이 감소하고, 더 많은 프로세스를 수용가능하다. 응답시간(response time, turn around time)은 늘지 않으면서 CPU이용률과 처리율이 높아진다.
    3. 프로그램을 메모리에 올리고 swap하는 필요한 IO횟수가 줄어든다.
        - I/O가 적게 일어나므로 더 빨리 실행 가능하다.
- 하드웨어만으로 메모리 가상화를 구현할 수 있을까?
    
    `주소 변환(가상 주소와 물리 주소 매핑)은 가능(MMU)`하지만, 정확한 변환을 위해선 운영체제의 지원이 필요하다. 그 이유는 운영체제만이 메모리의 빈 공간과 사용 중인 공간을 알고 있고, 메모리 사용 제어권이 있기 때문이다.  
    
- 메모리 관리 기법에서 정적 재배치와 동적재배치 방식에 대해서 설명하시오.
    
    → 정적 재배치
    
    - 프로그램이 실행 되기 이전에 메모리 주소가 고정되어 있다.
    - 과거에는 로더(loader)라 불리는 소프트웨어가 실행하고자 하는 실행 파일의 모든 주소를 원하는 물리 오프셋으로 변경했다. 이 방식은 잘못된 주소를 사용하여 불법적인 메모리 접근을 할 위험성이 있었고, 주소 공간을 재배치하는 것도 어려웠다.
    
    → 동적 재배치
    
    - 이 주소의 재배치는 `프로그램 실행 시`에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기에 동적 재배치라고 한다.
    - `동적(하드웨어 기반) 재배치(dynamic relocation)` 에서는 2개의 하드웨어 레지스터가 필요하다. 하나는 `베이스 레지스터(base register)`이고, 다른 하나는 `한계 레지스터(limit register)`이다.
    - 프로세스에 의해 생성되는 모든 주소가 다음 방법으로 프로세서에 의해 변환된다.
    
    ```jsx
    physical address = virtual address + base;
    ```
    
    - 이러한 주소 변환에 도움 주는 프로세서 일부를 `메모리 관리 장치(MMU, Memory Management Unit)`라고 한다.
    - 이 두 레지스터로 인해 간단하고 효율적인 메모리 가상화를 제공할 수 있게 되었다.
    
    → 동적 재배치의 문제점
    
    1. `내부 단편화`: 사용하지 않는 스택과 힙 공간이 단순히 낭비된다.
    2. `고정 크기의 주소 공간`: 충분한 물리 메모리가 있더라도 고정 크기에 주소 공간을 배치해야 하기에 내부 단편화 발생한다.
    
    (즉, 이 기법에선 전체 주소 공간이 하나의 베이스-리밋 쌍을 가지므로 스택과 힙 사이의 공간이 사용되지 않더라도 물리 메모리를 차지하게 된다.)
    
- 내부단편화와 외부단편화는 무엇인가?
    
    내부 단편화는 프로세스가 할당받은 메모리 공간 중 일부가 사용되지 않고 낭비되는 공간을 말한다. 외부 단편화는 메모리 공간 중간에 이미 할당된 작은 공간이 존재하여 큰 공간을 할당하지 못하는 공간을 말한다.
    
- 세그먼테이션 기법에 대해 설명하시오.
    
     세그먼테이션(Segmentation)
    
    - 가상 주소 공간을 여러 개의 세그먼트로 분할하는 기법이다.  논리적인 세그먼트마다 베이스와 리밋 쌍이 존재한다.
    - 세그먼트 테이블을 통해 매우 많은 세그먼트를 만들 수 있다. 대표적으로 코드, 스택, 힙 영역으로 나누어 사용한다.
    - 메모리를 절약하기 위해, 특정 메모리 세그먼트를 공유하는 것도 유용하다.
    
    → 세그먼테이션 기법의 문제점
    
    1. `외부 단편화`: 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다. 이는 기존 세그먼트를 정리하여 물리 메모리를 압축할 수 있겠지만, 세그먼트 복사는 메모리 부하가 굉장히 큰 연산이다.
    2. `드문드문 사용되는 주소 공간(sparse address area)`: 크기가 매우 크지만 드문드문 사용되는 주소 공간을 지원할 만큼 유연하지가 않다. 이 힙에 접근하기 위해선 그 힙 전체가 물리 메모리에 존재하여야 한다. 

- 페이징이란 무엇인가?
    - 프로세스의 주소 공간을 고정 크기의 단위로 나눈다. 이 각각의 고정 크기를 페이지(page)라고 부른다. 주소 공간을 페이지 단위로 분할하여 관리하는 방식이다.
- 페이징의 장점과 단점은 무엇인가?
- 페이징은 근본적으로 무슨 문제점이 있는지와 실질적으로 페이징을 가능하게 하는 하드웨어에 대해 설명하시오.
    
    
- 페이지 테이블은 무엇이며, 어떤 역활을 하는가?
    - 이 페이지 테이블은 가상 주소와 물리 주소 간의 매핑 정보를 담고 있는 자료구조이다. 프로세스마다 페이지 테이블을 둔다. 가상 페이지의 주소 변환 정보를 저장하여 주소 변환 과정에서 물리 페이지 주소로 변환하는데 사용된다.
- 페이지 테이블 엔트리에는 어떤 정보가 저장이 되는가?
    - 가상 페이지(페이지 테이블 엔트리 번호)에 해당 페이지가 매핑되는 `물리 페이지 프레임(PFN)`의 주소 정보가 저장되고 다음의 정보가 추가로 저장된다.
    1. `Valid bit` : 주소 변환의 여부를 나타낸다. 할당되지 않은 주소 공간을 표현하기 위해 반드시 필요하다.
    2. `Protection bit:` 페이지를 읽을 수 있는지, 쓸 수 있는지, 또는 실행될 수 있는지 표시한다.
    3. `Present bit`:  페이지가 물리 메모리에 있는지 혹은 디스크에 있는지(즉, 스왑아웃 되었는지) 표시한다.
    4. `Dirty bit`: 메모리에 반입된 후 페이지가 변경되었는지 여부를 표시한다.
    5. `Reference bit`: 페이지가 접근되었는지 추적하기 위해 사용된다. 이는 페이지를 교체할 때 매우 중요한 정보다.
- 문맥교환에서 성능저하를 TLB와 관련지어 생각해보자.
- 페이징에서 가상 주소 변환 과정을 설명해보시오.
    1. 프로세스가 가상 주소를 생성하면 운영체제와 하드웨어가 의미있는 물리 주소로 변환한다.
    2. 가상 주소를 `가상 페이지 번호(virtual page number, VPN)`와 페이지 내의 `오프셋` 2개의 구성 요소로 분할한다.
    3. 가상 주소 “21”을 이진 형식으로 변환하면 “010101”을 얻는다. 따라서 가상 주소 “21”은 가상 페이지 “01”의 5번째 바이트이다.
    4. 이 `가상 페이지 번호`를 가지고 `페이지 테이블의 인덱스로 사용`하여 가상 페이지 1이 어느 물리 프레임에 저장되어 있는지 찾을 수 있다.
- 페이징의 장점과 단점에 대해 설명하시오
    
    페이징은 주소 공간을 고정 크기의 페이지로 분할하여 사용하기 때문에 외부단편화 문제를 해결한다. 단 내부단편화 문제는 여전히 존재한다. 페이지 단위로 메모리를 관리하기에 메모리 할당과 해제가 쉽다. 단, 주소변환시에 페이지 테이블 엔트리에 접근하여 주소 변환을 수행해야 하므로 메모리 접근 시간이 2배가 된다.
    
- CPU가 물리 주소를 찾는 과정을 설명하시오.
    1. CPU에서 특정 데이터에 대한 가상 주소를 요청한다.
    2. MMU에서 해당 가상주소를 기반으로 TLB를 조회한다.
    
    ▶ 조회 결과, 데이터가 있다면 바로 해당 데이터를 반환한다.
    
    1. 조회 결과, 데이터가 없다면 메인 메모리의 page table 접근하여 해당 가상 주소의 물리주소를 검색한다.
    2. 해당 물리주소가 메모리에 적재되어 있는지 없는지 확인한다.
    
     ▶ 적재 되어 있다면 해당 물리주소의 데이터를 CPU에게 반환한다.
    
    1. 해당 물리주소가 메모리에 적재되어 있지 않은 경우, `page fault 인터럽트가 발생`하여 운영체제에게 전달된다.
    2. 운영체제는 page fault를 전달 받고 해당 페이지를 갖고 있는 프로세스에 접근하여 해당 페이지를 물리 메모리에 적재한다.
    3. 적재된 페이지에 대한 정보를 page table에 업데이트 한다.
    4. 이 후 CPU에게 해당 가상주소에 대한 데이터 검색을 다시 진행할 것을 요청한다. (페이지 폴트 핸들러가 종료되고, CPU는 인터럽트로 복귀)
    5. CPU는 다시 한번 해당 가상주소에 대한 데이터를 요청한다.
    6. MMU는 해당 가상주소를 page table에서 검색하여 물리 주소를 찾아 데이터를 CPU에게 반환한다.
        
        ![Screen Shot 2023-06-21 at 8.37.43 PM.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%200948e4b5d0054cce901c80b7f0abd345/Screen_Shot_2023-06-21_at_8.37.43_PM.png)
        

- 멀티 레벨 페이지 테이블이란 무엇인가?
    - 멀티레벨 페이지 테이블에서는 선형 페이지 테이블을 `트리 구조`로 표현한다.
- 멀티 레벨 페이지 테이블은 선형 페이지 테이블에 비해 어떤 장점과 단점이 있는가?
    
    [장점]
    
    1. 멀티 레벨 테이블은 페이지 디렉토리를 이용하여 사용된 주소 공간의 크기에 비례하여 페이지 테이블 주소 공간이 할당된다.
    2. 페이지 테이블을 페이지 크기로 분할함으로써 메모리 관리가 매우 용이하다. (선형 페이지 테이블처럼 연속된 물리 공간이 필요하지 않다. 빈 공간이 산재되어 있더라도 페이지 디렉터리를 이용하여 그 위치를 파악할 수 있기 때문이다)
    
    [단점]
    
    1. TLB 미스 시 주소 변환을 위해 추가 비용이 발생한다. TLB히트시 성능은 비슷하지만, 미스 시 두 배의 시간이 소요 된다. (페이지 디렉터리와 페이지 테이블 앤트리에 접근하기 위해서)
    2. 페이지 테이블 검색은 선형 페이지 테이블보다 복잡하다.
- 페이지 교체 알고리즘에 대해 설명하시오.
    - `LFU(Least-Frequently-Used)`: 가장 적은 빈도로 사용된 페이지를 교체한다.
    - `LRU(Least-Recently-Used)`: 가장 오래 전에 사용하였던 페이지를 교체한다.
- 시계 알고리즘은 무엇인가?
    - LRU를 완벽하게 구현하기 위해선 모든 메모리 참조 정보를 기록해야 하고, 가장 오래된 페이지를 검색하는 것은 매우 고비용의 연산이다. LRU처럼 효율적으로 동작하지만, 유사하게 구현하기 위해 시계 알고리즘(Clock Algorithm)을 사용한다.
    - 현재 가리키고 있는 페이지가 1이라면 최근에 사용되었으므로 0으로 설정되고 시계 바늘은 다음 페이지로 이동한다. 최근에 사용된 적이 없는 페이지를 찾을 때까지 검사한다.
    - 페이지를 교체할 때 페이지들을 랜덤하게 검사한다. 페이지의 reference bit가 0인지 확인한다. 추가로 갱신된 페이지를 교체한다면, 디스크에 변경 내용을 기록해야 하기 때문에 우선적으로 갱신되지 않은 페이지를 찾도록 한다.
- 쓰레싱(Threshing)이란 무엇인가?
    
    페이지 폴트가 빈번하게 발생하여 페이지를 교체하느라 CPU사용률이 감소하는 현상을 말한다. 운영체제는 CPU사용률이 낮으니 더 많은 프로세스를 메모리에 올리게 되고, 더욱 빈번하게 페이지 폴트가 일어나게 된다.
    
- 쓰레싱(Threshing)해결 방법에는 무엇이 있는가?
    1. 워킹 셋(working set) 알고리즘을 사용한다. 워킹 셋이란 프로세스가 실행 중에 일정 시간 동안 사용하는 페이지들의 집합이다. 메모리가 가득 차면 working set 단위로 페이지를 쫓아내고, 메모리에 로드할 때도 마찬가지다. 충분한 메모리가 있지 않다면, 메모리에 로드하지 않기 때문에 진입제어 방식이라고도 불린다.
    2. pageFaultFrequency 알고리즘을 사용한다. 페이지 폴트 비율에 상한과 하한을 두어, 상한을 넘으면 물리 메모리(frame)를 늘리고, 하한을 넘으면 줄인다. 남는 frame이 없으면 프로세스 단위로 page들을 통째로 쫒아내는 방식이다.
    3. 메모리 부족 킬러(out-ofmemory killer)프로그램을 실행하여 우선순위가 낮은 프로그램부터 종료시킨다.
    

## 1) 정적 재배치와 동적 재배치

→ 정적 재배치

- 프로그램이 실행 되기 이전에 메모리 주소가 고정되어 있다.
- 과거에는 로더(loader)라 불리는 소프트웨어가 실행하고자 하는 실행 파일의 모든 주소를 원하는 물리 오프셋으로 변경했다. 이 방식은 잘못된 주소를 사용하여 불법적인 메모리 접근을 할 위험성이 있었고, 주소 공간을 재배치하는 것도 어려웠다.

→ 동적 재배치

- 이 주소의 재배치는 `프로그램 실행 시`에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기에 동적 재배치라고 한다.
- `동적(하드웨어 기반) 재배치(dynamic relocation)` 에서는 2개의 하드웨어 레지스터가 필요하다. 하나는 `베이스 레지스터(base register)`이고, 다른 하나는 `한계 레지스터(limit register)`이다.
- 프로세스에 의해 생성되는 모든 주소가 다음 방법으로 프로세서에 의해 변환된다.

```jsx
physical address = virtual address + base;
```

- 이러한 주소 변환에 도움 주는 프로세서 일부를 `메모리 관리 장치(MMU, Memory Management Unit)`라고 한다.
- 이 두 레지스터로 인해 간단하고 효율적인 메모리 가상화를 제공할 수 있게 되었다.

→ 운영체제의 역할

1. 프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아야 한다. (빈 공간 리스트 자료 구조 검색)
2. 프로세스가 종료할 때 프로세스가 사용하던 메모리를 회수하고 다른 프로세스나 운영체제가 사용할 수 있게 한다.
3. 문맥 교환(context switch)가 일어날 때 추가 조치를 해야한다.
    1. 프로세스 전환 시 베이스와 리밋 쌍을 저장하고 복원한다.
    2. PCB에 값을 저장하고 실행한다.
    3. 현재 위치에서 새 위치로 주소 공간을 복사하고, 운영체제는 PCB에 저장된 베이스 레지스터를 갱신하여 새 공간을 가리키도록 한다.
4. 운영체제는 예외 핸들러 또는 호출될 함수를 제공해야 한다.

→ 동적 재배치의 문제점

1. `내부 단편화`: 사용하지 않는 스택과 힙 공간이 단순히 낭비된다.
2. `고정 크기의 주소 공간`: 충분한 물리 메모리가 있더라도 고정 크기에 주소 공간을 배치해야 하기에 내부 단편화 발생한다.

(즉, 이 기법에선 전체 주소 공간이 하나의 베이스-리밋 쌍을 가지므로 스택과 힙 사이의 공간이 사용되지 않더라도 물리 메모리를 차지하게 된다.)

## 2) 세그먼테이션(Segmentation)

- 가상 주소 공간을 여러 개의 세그먼트로 분할하는 기법이다.  논리적인 세그먼트마다 베이스와 리밋 쌍이 존재한다.
- 세그먼트 테이블을 통해 매우 많은 세그먼트를 만들 수 있다. 대표적으로 코드, 스택, 힙 영역으로 나누어 사용한다.
- 메모리를 절약하기 위해, 특정 메모리 세그먼트를 공유하는 것도 유용하다.

→ 세그먼테이션 기법의 문제점

1. `외부 단편화`: 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다. 이는 기존 세그먼트를 정리하여 물리 메모리를 압축할 수 있겠지만, 세그먼트 복사는 메모리 부하가 굉장히 큰 연산이다.
2. `드문드문 사용되는 주소 공간(sparse address area)`: 크기가 매우 크지만 드문드문 사용되는 주소 공간을 지원할 만큼 유연하지가 않다. 이 힙에 접근하기 위해선 그 힙 전체가 물리 메모리에 존재하여야 한다. 
