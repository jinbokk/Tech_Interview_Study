# 🤓 이진복

## 1. 브라우저의 동작 방식에 대해 이해한 대로 설명 해 본다면 ?

```
브라우저는 사용자가 주소창에 입력한 도메인 주소의 웹 서버에 파일을 요청하고 응답받는 과정을 통해 
HTML, CSS, Javascript, 이미지 등의 파일을 다운로드 받는다. 

이후 브라우저는 렌더링 엔진을 통해 HTML 파일을 파싱하여 DOM Tree를 만들고, 
CSS 파일을 파싱하여 CSSOM Tree를 만든 뒤 이를 합쳐 Render Tree를 만든다. 

렌더링 엔진의 렌더러가 이를 이용하여 Layout과 Paint 작업을 통해
사용자가 보는 View를 만든다.

또한, 브라우저의 BOM과 Javascript를 사용하여 사용자와의 상호작용을 처리한다.
```


## 2. 브라우저에서 DOM 이 무엇인가 ?
```
DOM은 "Document Object Model"의 약자로, 웹 페이지의 구조와 내용을 표현하는 객체 기반의 
프로그래밍 인터페이스이다. 웹 브라우저가 HTML 문서를 파싱하여 생성하는 Tree 구조로, 
각각의 HTML 요소를 노드로 표현한다.
```

## 3. 브라우저에서 DOM 이 왜 필요한가 ?
```
DOM은 웹 페이지의 각 요소(태그, 텍스트, 이미지 등)를 JavaScript나 다른 프로그래밍 언어에서 
접근하고 조작할 수 있는 방법을 제공하며, 이를 통해 JavaScript는 웹 페이지의 내용, 구조, 스타일 등을 
동적으로 조작하거나 변경할 수 있다.
```

## 4. 브라우저에서 각각의 렌더링 엔진으로 DOM Tree를 작성하는데, Naver 웹사이트를 크롬에서 보나 엣지에서 보나 똑같은 이유는?
```
표준화된 웹 기술과 W3C (World Wide Web Consortium)의 역할 때문이다.

W3C는 웹 표준을 개발하고 유지 관리하는 국제 표준화 기구로서, 웹 기술의 표준을 정의하고 웹 브라우저들이 
이를 준수하도록 지원한다. HTML, CSS, JavaScript 등의 웹 기술은 W3C에서 정의한 표준에 따라 개발되고 구현된다.

크롬과 엣지는 둘 다 W3C의 웹 표준을 준수하는 렌더링 엔진을 사용한다. 
(크롬은 Blink 엔진, 엣지는 Chromium 기반의 엔진) 
이 두 엔진은 웹 페이지를 W3C의 표준 사양에 따라 렌더링한다. 

따라서, Naver 웹사이트의 경우에도 크롬과 엣지에서 동일한 DOM Tree를 생성하고, 
사용자 View 또한 동일할 수 있는 것이다.
```

## 5. SSR과 CSR이 무엇인지 이해한 대로 설명 해 본다면?
```
- SSR
  브라우저가 렌더링을 하기 위해 HTML, CSS 파일을 파싱하기 전에,
  서버측에서 HTML에 UI를 작성하여 브라우저에 넘겨주는 방식이다.

- CSR
  서버는 브라우저에게 Contents가 비어있는 HTML 파일을 넘겨주고,
  클라이언트는 Javascript를 실행하여 비어있던 HTML에 Contents를 채워 UI를 작성하는 방식이다.
```

## 6. SSR과 CSR이 어떠한 차이를 가지고 있는지?
```
HTML파일에 UI를 채우는(렌더) 주체가 다르다는 것이 제일 큰 차이이다. 서버측에서 미리 처리하여 브라우저에
넘겨주느냐, 클라이언트측에서 비어있는 내용을 채우느냐의 차이이다.
```

## 7. SSR과 CSR의 장단점은 무엇일까?
```
- SSR
  - 장점
    - 초기 로딩 속도: 서버에서 HTML을 완전히 렌더링하여 클라이언트에게 전달하므로, 초기 로딩 속도가 빠르다.
    - 검색 엔진 최적화 (SEO): 서버에서 완성된 HTML을 제공하므로, 검색 엔진 크롤러가 
      콘텐츠를 쉽게 수집할 수 있어 SEO에 유리하다.

  - 단점
    - 서버 부하: 서버에서 렌더링을 처리하므로 서버 부하가 증가할 수 있다.
    - 초기 로딩 시간: 완전한 HTML을 클라이언트에게 전달해야 하므로, 초기 로딩 시간이 길어질 수 있다.

- CSR
  - 장점
   - 인터랙티브한 경험: 페이지의 초기 로딩 후에 JavaScript를 통해 데이터를 가져와 동적으로 렌더링하므로, 
   사용자와의 인터랙션이 뛰어나다.
   - 서버 부하 감소: 서버는 데이터 API를 제공하고 클라이언트는 필요한 데이터만 요청하므로, 
   서버 부하가 상대적으로 감소한다.

  - 단점
    - 초기 로딩 속도: HTML 문서를 클라이언트에게 전달하고, 클라이언트에서 JavaScript를 다운로드하고
      실행해야 하므로 초기 로딩 속도가 느릴 수 있다.
```

# 🤓 지준혁

## 1. 운영체제가 왜 필요할까요?

```
- 컴퓨터 시스템을 편리하게 사용할 수 있는 `환경 제공`
    
- 컴퓨터 시스템 `자원의 효율적 관리`
    
- 운영체제는 이런 목표를 달성하기 위해 가상화라는 기법을 사용한다.
```


## 2. 운영체제는 자원(CPU, 메모리)을 어떻게 가상화시키고 있나요?
    

```
1) 운영체제는 하나의 프로세스를 실행한 후, 얼마 후 중단시키고 다른 프로세스를 실행하는 작업을 반복하면서 
  여러 개의 가상 CPU가 존재하는 것처럼 보이게 한다. (시분할 기법, `CPU 가상화`)
    
2) 각 프로세스는 자신만의 `가상 주소 공간(virtual address space)`을 갖는다. 
  운영체제는 이 가상 주소 공간을 컴퓨터와 물리 메모리로 `매핑(mapping)`한다. 
  실행 중인 프로그램의 입장에서는 자기 자신만의 물리 메모리를 갖는다고 생각하지만, 
  실제로 물리 메모리는 공유 자원이고. 운영체제에 의해 관리된다. (`메모리 가상화`)
    
cf. CPU가상화에 대한 질문이 주어졌을 땐, 아래의 키워드가 들어가야 한다. 
  이는 운영체제가 하나의 물리적인 CPU를 분할하여 여러 개의 가상 CPU로 만들어 
  `각 가상 CPU에게 독립적인 실행환경을 제공하는 기술`을 말한다. 
  이런 기술은 가상 머신 기반(VM) 또는 컨테이너 기반(docker)으로 제공된다.
```

    

## 3. 프로세스와 스레드는 무엇이고, 어떤 특징을 가지나요?

```
- 프로세스 : `실행 중인 프로그램`을 의미한다.
- 프로세스는 운영체제로부터 `독립된 주소 공간을 할당`받는다.
- 스레드: 프로세스 내에서 `실행되는 흐름의 단위`를 말한다.

- 특징
  - 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 각 스레드는 동시에 실행될 수 있다.
  - 스레드는 `각각 별도의 스택(Stack)메모리 영역`을 가지지만
    코드, 데이터, 힙 영역 은 프로세스 내 모든 스레드가 공유한다.
```


## 4. 메모리를 여러 영역으로 나눔으로써 얻는 이점은 무엇인가요? 나뉜 영역에 대해서도 설명해주세요.
    

```
`불필요한 코드 중복을 제거하여 효율적인 메모리 사용을 가능하게 하고, 관리가 용이`해진다. 

 - Code 영역은 코드가 저장되는 영역으로 프로그램 자체에서는 모두 같은 내용이기에 공유하며, 
   읽기 전용으로 설정한다.

 - Data 영역은 전역 변수, 정적 변수, 상수가 저장되는 영역으로 프로그램이 실행되는 동안 데이터를 공유한다.

 - Stack 영역은 지역변수, 함수 호출, 매개변수 등이 저장되는 영역으로 스택 프레임을 통해 
   함수 호출 관련 정보들을 효율적으로 관리할 수 있다.

 - Heap 영역은 동적으로 할당된 메모리가 저장되는 영역이다.
```

    

## 5. 구글 크롬 브라우저는 스레드나 프로세스 어떤 방식으로 구현되어 있을까요? 각각의 장단점을 말해보고 본인이라면 어떤식으로 구현했을지 말해 보세요.



```
크롬은 멀티프로세스 아키텍처를 사용하여 각각의 탭을 별도의 프로세스로 실행한다.
이 프로세스는 웹 페이지의 렌더링, JavaScript 실행 등을 담당한다.

각 탭 내에서는 또한 작업을 병렬로 처리하기 위해 스레드를 사용하고 있으며,
이때 스레드는 탭 내에서 동시에 실행되는 작은 작업 단위이다.

따라서 크롬은 멀티프로세스와 멀티스레딩을 결합하여 탭 별로 프로세스를 분리하고 
각 프로세스 내에서는 다중 스레드를 활용하여 작업을 동시에 처리한다.

이렇게 함으로써 안정성, 보안, 성능 측면에서 이점을 얻을 수 있다.
```

    

## 6. 프로세스 상태에 대해서 설명해보세요.

```
프로세스는 크게 3가지 상태가 있다.

1. `실행(Running)`: 프로세스는 프로세서에서 실행중이다. 명령어를 실행하고 있다.

2. `준비(Ready)`: 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 
    실행하고 있는 등의 이유로 대기 중이다.

3. `대기(Blocked)`: 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산이다. 
    ex) 입출력 요청 시 입출력이 완료될 때까지 대기(blocked)상태가 된다.
```

    

## 7. PCB(Process Control Block)은 무엇이고, 왜 필요할까요?

```
- 운영체제는 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보(`Process Control Block, PCB`)를 둔다.
  이는 OS 메모리 영역 중 Data부분에 저장된다.

- PCB가 관리하는 정보
     1. OS가 관리상 사용하는 정보
       - Process state(프로세스 상태), Process ID(프로세스 이름), scheduling information(스케줄링 정보)

     2. CPU 수행 관련 하드웨어 값
       - `Program counter(현재 실행 중인 명령어의 주소를 가리키는 레지스터)`
       - registers(CPU 내부에 위치한 작은 메모리 공간)

     3. 메모리 관련
      - code, data, stack의 위치 정보(stack pointer - 스택 최상단 가리키는 포인터)
```
